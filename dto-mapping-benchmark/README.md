# 🔁 데이터 변환 로직 위치에 따른 성능 분석의 후속연구

## 📌 실험 목적

이번 실험에서는 대부분의 연관 데이터가 `LAZY` 로딩 설정으로 인해 성능 차이가 미미했는지 확인해보아야하고,

추가적으로 모든 연관관계를 **`EAGER`로 강제 설정**하고,

대용량 데이터를 즉시 로딩하도록 변경한 뒤, 다시 한 번 계층별 성능 차이를 측정하였다.

---

## 실험 동기부여

### **[1. 시작점: 실제 프로젝트 코드 리뷰](https://github.com/Likelion-YeungNam-Univ/CoCoNut-was/pull/8)**

- '멋쟁이 사자처럼 대학 해커톤' 프로젝트 진행 중, **JPA 연관관계 설정**에 대한 코드 리뷰를 받음.
- 당시 `@ManyToOne`에 기본 전략인 **`EAGER`를 사용한 코드**에 대해, 성능 저하를 유발할 수 있으니 **`LAZY` 로딩을 적용하라는 피드백**이 있었음.

### **2. 의문**

- **새로운 의문 :** Fetch 전략(`EAGER` vs `LAZY`)의 차이가 정말 **성능에 얼마나 큰 영향**을 미칠까?
- **이전 실험의 의문 :** 만약 **DTO 변환을 어디서 하느냐**에 따라 성능 차이가 발생하지는 않을까?

---

### 🔍 LAZY vs EAGER: 개념 차이

| 항목 | LAZY (지연 로딩) | EAGER (즉시 로딩) |
| --- | --- | --- |
| 기본값 | `@OneToMany`, `@ManyToMany`는 기본 LAZY | `@ManyToOne`, `@OneToOne`은 기본 EAGER |
| 데이터 로딩 시점 | **필요할 때 (실제로 접근할 때)** DB에서 불러옴 | **엔티티 조회와 동시에** 관련 엔티티도 같이 불러옴 |
| 쿼리 수 | 필요할 때마다 추가 쿼리 발생 | 처음부터 `JOIN` 등으로 한번에 불러옴 |
| 사용 예시 | 리스트나 대용량 연관 데이터 | 단일 관계, 무조건 같이 써야 할 경우 |

---

## 🧭 실험 환경 - 실패

| Device | MacBook Pro M4 |
| --- | --- |
| CPU | M4 Pro 12 core |
| RAM | DDR5X 24GB |
| OS | macOS Sequoia |
| IDE | IntelliJ |
| Framework | Spring Boot 3(Java) |
| API Tool | Postman |

---

## ⚙️ 실험 조건

| 항목 | 값 |
| --- | --- |
| Fetch 전략 | `LAZY` , `EAGER` 두 조건 비교 |
| 유저 수 | 1명 |
| 게시글 수 | 10,000개 (해당 유저에게 모두 작성) |
| 요청 방식 | POST, GET |
| 반복 횟수 | 10000회, 1000회 |

> 게시글 10,000개가 한 유저에 연관되어 있어, 변환 시 성능 부하가 실제로 발생
> 

---

## 🧪 실험 단계 (후속 실험: F ~ G)

| 단계 | 설명 |
| --- | --- |
| **F** | 유저 1명에게 게시글 10,000개 작성 (`POST /posts`) |
| **G** | 해당 유저를 1000회 반복 조회 (`GET /users/{id}`) |

---

## 📊 실험 결과 요약 - LAZY 방식

| 평균 응답 시간 (ms) | F (생성) | G (조회) |
| --- | --- | --- |
| v1 (내부 메서드) | 4 | 61 |
| v2 (서비스 계층) | 22 | 44 |
| v3 (컨트롤러 계층) | 4 | 46 |
| v4 (매퍼 클래스) | 4 | 67 |

## 📊 실험 결과 요약 - EAGER 방식

| 평균 응답 시간 (ms) | F (생성) | G (조회) |
| --- | --- | --- |
| v1 (내부 메서드) | 5 | 64 |
| v2 (서비스 계층) | 25 | 48 |
| v3 (컨트롤러 계층) | 26 | 51 |
| v4 (매퍼 클래스) | 28 | 75 |

## 📊 실험 결과 요약 - 기본 설정

| 평균 응답 시간 (ms) | F (생성) | G (조회) |
| --- | --- | --- |
| v1 (내부 메서드) | 5 | 67 |
| v2 (서비스 계층) | 27 | 52 |
| v3 (컨트롤러 계층) | 6 | 52 |
| v4 (매퍼 클래스) | 6 | 75 |

### 📌 **성능 저하 원인 분석 및 재실험 필요성 동기**

- **반복적 쿼리 발생**: 이로 인해 불필요한 데이터베이스 쿼리가 반복적으로 실행되어 **서비스 F의 성능 저하**가 확인됨.
- **변인 통제 실패**: 초기 실험에서 **`System.out.print`*와 **`log.info`** 같은 로깅 코드로 인해 불필요한 **오버헤드**가 발생. (실제 결과에는 반영하지 않고 버림)
- **비교 조건 불일치**: 각 소스코드(v1, v2 등)에 동일한 환경 조건을 적용하지 않아 정확한 비교가 어려웠음.
    - **`v2` 소스코드의 `EntityGraph` 오용**: **`v2`** 코드에만 **`EntityGraph`*를 잘못 적용하여 **N+1 문제**를 유발.



---

## 🧭 실험 환경2 (재실험)

| Device | Desktop |
| --- | --- |
| CPU | i5-13400F |
| RAM | DDR5 32GB |
| OS | Windows 11 Pro |
| IDE | IntelliJ |
| Framework | Spring Boot 3(Java) |
| API Tool | Postman |

---

## ⚙️ 실험 조건

| 항목 | 값 |
| --- | --- |
| Fetch 전략(추가) | `LAZY` , `EAGER` 두 조건 비교 |
| 유저 수 | 1명 |
| 게시글 수 | **20,000개 (해당 유저에게 모두 작성)** |
| 요청 방식 | POST, GET |
| 반복 횟수 | 20000회, 1000회 |

> 게시글 10,000개가 한 유저에 연관되어 있어, 변환 시 성능 부하가 실제로 발생
> 

---

## 🧪 실험 단계 (후속 실험: F ~ G)

| 단계 | 설명 |
| --- | --- |
| **F** | **유저 1명에게 게시글 20,000개 작성 (`POST /posts`)** |
| **G** | 해당 유저를 1000회 반복 조회 (`GET /users/{id}`) |

---

## 📊 실험 결과 요약 - LAZY 강제

| 평균 응답 시간 ms 
(총 시간 min.sec) | F (생성) | G (조회) |
| --- | --- | --- |
| v1 (내부 메서드) | 13 (29.06) | 147 (3.16) |
| v2 (서비스 계층) | 13 (28.23) | 121 (2.48) |
| v3 (컨트롤러 계층) | 12 (28.07) | 122 (2.57) |
| v4 (매퍼 클래스) | 13(28.21) | 206 (4.22) |


    
## 📊 실험 결과 요약 - EAGER 강제

| 평균 응답 시간 ms 
(총 시간 min.sec) | F (생성) | G (조회) |
| --- | --- | --- |
| v1 (내부 메서드) | 63 (49.08) | 196 (4.09) |
| v2 (서비스 계층) | 64 (48.38) | 165 (3.50) |
| v3 (컨트롤러 계층) | 65 (48.49) | 158 (3.44) |
| v4 (매퍼 클래스) | 61 (47.56) | 145 (3.12) |

    

## 📊 실험 결과 요약 - 기본 설정

| 평균 응답 시간 ms 
(총 시간 min.sec) | F (생성) | G (조회) |
| --- | --- | --- |
| v1 (내부 메서드) | 15 (30.22) | 196 (4.11) |
| v2 (서비스 계층) | 14 (29.37) | 163 (3.40) |
| v3 (컨트롤러 계층) | 12 (28.50) | 166 (3.40) |
| v4 (매퍼 클래스) | 13 (28.52) | 202 (4.19) |

    

# 통합 정리 표

| 평균 응답 시간 ms (총 시간 min.sec) | F (기본) | F (LAZY) | F (EAGER) | G (기본) | G (LAZY) | G (EAGER) |
| --- | --- | --- | --- | --- | --- | --- |
| v1 (내부 메서드) | 15 (30.22) | 13 (29.06) | 63 (49.08) | 196 (4.11) | 147 (3.16) | 196 (4.09) |
| v2 (서비스 계층) | 14 (29.37) | 13 (28.23) | 64 (48.38) | 163 (3.40) | 121 (2.48) | 165 (3.50) |
| v3 (컨트롤러 계층) | 12 (28.50) | 12 (28.07) | 65 (48.49) | 166 (3.40) | 122 (2.57) | 158 (3.44) |
| v4 (매퍼 클래스) | 13 (28.52) | 13(28.21) | 61 (47.56) | 202 (4.19) | 206 (4.22) | 145 (3.12) |

---

## 🔍 실험 결과 해석: Fetch 전략에 따른 각 버전별 성능 심층 분석

**※ 본 분석은 제공된 최종 실험 결과표를 기반으로, JPA 동작 원리와 JVM 최적화 관점에서 재구성되었음.**

### **1. F 단계 (생성): EAGER 전략의 함정과 N+1 문제의 실증**

- **기본 / LAZY 강제 전략 (모든 버전: 12~15ms)**
    - **결과:** 모든 버전이 매우 빠르고 유사한 성능을 보임.
    - **분석:** 이는 게시글 1개 생성 시, 연관된 User 엔티티만 조회(`SELECT`)하고 Post를 삽입(`INSERT`)하기 때문임. User가 가진 수만 개의 기존 게시글은 LAZY 로딩 덕분에 전혀 건드리지 않으므로, DTO 변환 위치에 따른 성능 차이가 거의 없는 **이론과 일치하는 정상적인 결과**임.
- **EAGER 강제 전략 (모든 버전: 61~65ms)**
    - **결과:** 모든 버전의 성능이 **약 4~5배 급격히 저하**됨.
    - 분석 : EAGER fetch의 대표적인 성능 저하 사례임.
        - 초반에는 게시물 생성 시 연관된 게시물 자체가 적으므로 빠르게 처리됨(ok)
        - 중간 단계쯤 부터는 User를 조회 시 연관된 게시물 10000+-개를 가져오므로 평균값 정도의 속도로 느려짐.
        - 후반에는 거의 100ms가 넘어가는 속도를 보여줌.
        - 이 결과의 평균이 61~65ms가 되는 것.

### 2. G 단계 (조회): 성능 병목의 이동과 아키텍처의 유불리 변화

- **기본 / LAZY 강제 전략: 지연 로딩(LAZY) 환경에서의 아키텍처별 효율성 분석**

**이를 구분하기 좋은 기준은 스프링이 관리하는 Bean에 있냐 아니냐로 나눌 수 있음.**

- **V2(서비스), V3(컨트롤러)가 가장 우수 (121~166ms)**
    - **분석**
        - 이 환경의 성능 병목은 LAZY 로딩으로 프록시 객체를 가져온 후, 메모리에서 2만 개의 DTO로 변환하는 연산임.
        - DTO 변환 로직이 스프링이 관리하는 Bean(서비스, 컨트롤러)에 있을 때, JPA 프록시 객체를 다루는 과정이 JVM에 의해 최적화되기 가장 유리함.
        - **책임(관심사) 분리 원칙**에 부합하여 구조적으로나 성능적으로 가장 안정적인 결과를 보였음.
- **V1(내부 메서드), V4(매퍼 클래스)가 상대적으로 저조 (147~206ms)**
    - **분석**
        - `V1`은 JPA가 관리하는 엔티티 내부에서 직접 변환을 수행
        - `V4`는 외부의 정적(static) 메서드를 호출함
        - 두 방식 모두 스프링 Bean이 제공하는 AOP나 트랜잭션 기반의 최적화 이점을 누리지 못함
            - AOP : 관점 지향 프로그래밍, 반복되는 기능을 분리하여 관리하는 프로그래밍 패러다임
            - **엔티티는 스프링 Bean에 의해 관리되지 않음.!! JPA 관리 엔티티임.**

- **EAGER 강제 전략: 즉시 로딩(EAGER) 환경에서의 순수 매핑 성능 분석**

**이 경우는 이미 모든 정보가 메모리에 올라와있기에, 순수 Java 내부에서의 최적화 문제임.**

- **V4(매퍼 클래스)의 성능 역전 현상 분석 (145ms)**
    - **분석:** **아무런 부가기능 없이 데이터 복사에 집중하는 V4의 정적(static) 매퍼 방식이 가장 빠른 성능**을 보임.
- **V1(내부 메서드)의 아쉬운 성능 (196ms)**
    - **분석:** JPA가 관리하는 **영속 상태의 엔티티 내부에서 직접 변환 로직을 수행하는 것의 오버헤드**가 스프링 Bean 내부의 변환 로직의 오버헤드보다 큼.

---

### 💡 정리

- *F(생성)**에서는 EAGER 전략이 N+1 문제를 유발하여 모든 아키텍처의 성능을 저하시키는 것을 확인했음.
- *G(조회)**에서는 성능 병목이 "어떤 Fetch 전략을 사용하는가"에 따라 극적으로 이동했음.
    - **LAZY 로딩 시:** 성능 병목은 '프록시 객체(가짜 객체 꼬리표) 핸들링'이며, V2(서비스 계층)가 가장 효율적이었음.
    - **EAGER 로딩 시:** 성능 병목은 '순수 메모리 매핑'이며, V4(매퍼 클래스)가 가장 효율적이었음.

이 결과는 특정 아키텍처가 절대적으로 우월한 것이 아니라, **데이터 로딩 전략이라는 런타임 환경에 따라 최적의 DTO 변환 구조가 달라진다**는 중요한 사실을 보여줌.

### 주요 통찰

개발자는 현재 비즈니스 로직에 가장 적합한 Fetch 전략을 먼저 선택하고, 그 전략 하에서 **성능 저하가 예상되는 지점(프록시 핸들링 or 대량 매핑)을 가장 효율적으로 처리할 수 있는 DTO 변환 아키텍처**를 채택해야 최적의 성능을 이끌어낼 수 있음.
